{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"El objetivo de la tarea era demostrar los conocimientos del uso de MarkDown, Git, Git Actions y Docker. Para ello, se ha creado un repositorio Git , implementado un Workflow de Git Actions y creado un contenedor de servicios NGINX en Docker . Toda esta documentaci\u00f3n se ha realizado integramente en Markdown par mejorar su legibilidad y presentaci\u00f3n.","title":"Tarea 0"},{"location":"conclusiones/","text":"Para dar por finalizada la tarea, es importante destacar la utilidad de las distintas herramientas empleadas en este tema: Git es la herramienta de control de versiones m\u00e1s usada popularmente en proyectos, por lo que es especialmente \u00fatil conocerla. Como ejemplo, yo llevo 3 a\u00f1os trabajando como desarrollador web y a\u00fan no he estado en ning\u00fan proyecto que no use Git, ya sea por no usarlo o por sustituirlo por otra tecnolog\u00eda. Git Actions era una herramienta nueva para mi, no la hab\u00eda utilizado nunca y me ha parecido muy pr\u00e1ctica para implementar la integraci\u00f3n continua del c\u00f3digo. Adem\u00e1s, la herramienta mkdocs tambi\u00e9n me era nueva y me ha parecido muy \u00fatil para mis proyectos personales, ya que genera una documentaci\u00f3n muy r\u00e1pida y vistosa. Docker es el gestor de contenedores m\u00e1s popular, lo hab\u00eda utilizado en alguna ocasi\u00f3n pero esta vez me ha resultado bastante m\u00e1s entendible. Es una herramienta bastante pr\u00e1ctica y \u00fatil. Gracias por su tiempo, Francisco Manuel S\u00e1nchez Collado.","title":"Conclusiones"},{"location":"docker/","text":"A continuaci\u00f3n se va a explicar c\u00f3mo se crea un contenedor Docker de NGINX . Creaci\u00f3n del volumen Para que el contenedor pueda persistir datos y servir correctamente la documentaci\u00f3n, hay que crear un volumen con el workspace con la documentaci\u00f3n. Para esto, haremos checkout de la rama principal a la generada por la documentaci\u00f3n. Como truco, para evitar perder documentos que a\u00fan no est\u00e9n terminados y por lo tanto no querramos subir al repositorio, podemos hacer stash (pila) para almacenar los cambios y cuando hayamos acabado en la otra rama, hacer unstash (desapilar) para recopilar los archivos guardados. Una vez en la rama con el c\u00f3digo HTML generado para la documentaci\u00f3n, crearemos el archivos docker-compose.yml con las siguientes propiedades: image: la imagen que se usar\u00e1 para el contenedor, en este caso la versi\u00f3n reducida de NGINX llamada Alpine ports: el mapeo de los puertos, en este caso se mapea el puerto 80 al 8085, lo que permite acceder por el puerto 8085 al NGINX container_name: nombre del contenedor volumes: la configuraci\u00f3n del volumen para que el servidor pueda acceder a los ficheros generados por mkdocs \u00a1Importante! Antes de continuar modifica la ruta del volumen del docker-compose por la ruta a la carpeta en la que est\u00e9 el repositorio en tu equipo. Con el archivo preparado, ejecutamos en esa carpeta el comando docker-compose up -d para levantar el contenedor desde el compose en modo demonio: Para comprobar que el contenedor se ha levantado correctamente, ejecutamos el comando docker ps : Con el contenedor funcionando, podremos ver nuestra documentaci\u00f3n en la p\u00e1gina http://localhost:8085 Finalmente, cuando hayamos acabado con el contenedor, podremos desmontarlo con el comando docker-compose down -v y adem\u00e1s eliminar\u00e1 el volumen que cre\u00f3 dentro del contenedor por el par\u00e1metro -v.","title":"Docker"},{"location":"docker/#creacion-del-volumen","text":"Para que el contenedor pueda persistir datos y servir correctamente la documentaci\u00f3n, hay que crear un volumen con el workspace con la documentaci\u00f3n. Para esto, haremos checkout de la rama principal a la generada por la documentaci\u00f3n. Como truco, para evitar perder documentos que a\u00fan no est\u00e9n terminados y por lo tanto no querramos subir al repositorio, podemos hacer stash (pila) para almacenar los cambios y cuando hayamos acabado en la otra rama, hacer unstash (desapilar) para recopilar los archivos guardados. Una vez en la rama con el c\u00f3digo HTML generado para la documentaci\u00f3n, crearemos el archivos docker-compose.yml con las siguientes propiedades: image: la imagen que se usar\u00e1 para el contenedor, en este caso la versi\u00f3n reducida de NGINX llamada Alpine ports: el mapeo de los puertos, en este caso se mapea el puerto 80 al 8085, lo que permite acceder por el puerto 8085 al NGINX container_name: nombre del contenedor volumes: la configuraci\u00f3n del volumen para que el servidor pueda acceder a los ficheros generados por mkdocs \u00a1Importante! Antes de continuar modifica la ruta del volumen del docker-compose por la ruta a la carpeta en la que est\u00e9 el repositorio en tu equipo. Con el archivo preparado, ejecutamos en esa carpeta el comando docker-compose up -d para levantar el contenedor desde el compose en modo demonio: Para comprobar que el contenedor se ha levantado correctamente, ejecutamos el comando docker ps : Con el contenedor funcionando, podremos ver nuestra documentaci\u00f3n en la p\u00e1gina http://localhost:8085 Finalmente, cuando hayamos acabado con el contenedor, podremos desmontarlo con el comando docker-compose down -v y adem\u00e1s eliminar\u00e1 el volumen que cre\u00f3 dentro del contenedor por el par\u00e1metro -v.","title":"Creaci\u00f3n del volumen"},{"location":"git/","text":"A continuaci\u00f3n, se detallan los pasos seguidos para la creaci\u00f3n de este proyecto y su sistema de carpetas. Importante: Por efectividad y al ya conocerse el funcionamiento de Git, este proyecto se ha creado mediante interfaz gr\u00e1fica. Creaci\u00f3n del repositorio El repositorio se ha creado mediante el bot\u00f3n de \"New\" de la p\u00e1gina GitHub : Una vez creado, se ha clonado a local mediante el enlace HTTPS en el bot\u00f3n \"Code\": Una vez conseguido el enlace, lo clonamos en local con la herramienta Git Extensions Una vez con el repositorio en local, se pueden crear la estructura de carpetas y archivos mediante el explorador de archivos de Windows.","title":"Git"},{"location":"git/#creacion-del-repositorio","text":"El repositorio se ha creado mediante el bot\u00f3n de \"New\" de la p\u00e1gina GitHub : Una vez creado, se ha clonado a local mediante el enlace HTTPS en el bot\u00f3n \"Code\": Una vez conseguido el enlace, lo clonamos en local con la herramienta Git Extensions Una vez con el repositorio en local, se pueden crear la estructura de carpetas y archivos mediante el explorador de archivos de Windows.","title":"Creaci\u00f3n del repositorio"},{"location":"gitActions/","text":"Para la creaci\u00f3n de un flujo de trabajo en Git, primero configuraremos MKDocs, una herramienta para la generaci\u00f3n autom\u00e1tica de documentaci\u00f3n, generando archivos HTML, CSS y JavaScript desde archivo de MarkDown . Creaci\u00f3n de MKDocs Para la conversi\u00f3n de los archivos mediante MKDocs, se debe crear un archivo de configuraci\u00f3n mkdocs.yml , en el que se pueden configurar varios par\u00e1metros: site_name: nombre con el que aparecer\u00e1 la p\u00e1gina generada nav: men\u00fa de navegaci\u00f3n de la p\u00e1gina, compuesto por los distintos archivos de documentaci\u00f3n MarkDown doc_dir: directorio en el que se almacenan los archivos de documentaci\u00f3n theme: en este caso, se ha usado el tema simple-blog Descarga del tema local Como peque\u00f1o inciso, se describir\u00e1n los pasos realizados para la importaci\u00f3n del tema simple-blog . Prerrequisitos: Python instalado, preferiblemente Python 3 (yo he usado la versi\u00f3n 3.12) Los comandos que he empleado son para Windows 10 Instalaci\u00f3n del tema: Para la instalaci\u00f3n del tema, se deber\u00e1 crear un entorno virtual en la carpeta del proyecto: Una vez instalado, lo activamos: Configuraci\u00f3n del tema: Una vez instalado, a\u00f1adimos la l\u00ednea de configuraci\u00f3n pertinente al mkdocs.yml: theme: name: simple-blog Configuraci\u00f3n del workflow Dentro del directorio .github creamos un directorio nuevo llamado \"workflows\" y dentro de este, un archivo de configuraci\u00f3n deploy_docs.yml. En este fichero a\u00f1adiremos las configuraciones de la pipeline: name: el nombre del flujo de trabajo, aparecer\u00e1 en GitHub on: se encarga de definir qu\u00e9 evento lanzar\u00e1 el flujo, en este caso ser\u00e1 on push branches main , ya que se lanzar\u00e1 siempre que se haga un push en la rama main permissions: los permisos del token, para permitir al workflow realizar las operaciones necesarias jobs: define los trabajos que realizar\u00e1 el flujo, en este caso Una vez configurado el archivo, hacemos commit y push para subir los cambios y lanzar la primera ejecuci\u00f3n del flujo de trabajo. Activaci\u00f3n de GitHub Pages Con la documentaci\u00f3n subida y la rama gh-pages generada por el workflow, ya solo nos queda habilitar la visualizaci\u00f3n de la documentaci\u00f3n mediante la opci\u00f3n de pages de GitHub: Una vez seleccionada esta opci\u00f3n, el despliegue en las p\u00e1ginas se pondr\u00e1 en cola, apareciendo lo siguiente cuando termine: Una vez desplegado, se puede acceder a la documentaci\u00f3n hosteada en este enlace","title":"Git Actions"},{"location":"gitActions/#creacion-de-mkdocs","text":"Para la conversi\u00f3n de los archivos mediante MKDocs, se debe crear un archivo de configuraci\u00f3n mkdocs.yml , en el que se pueden configurar varios par\u00e1metros: site_name: nombre con el que aparecer\u00e1 la p\u00e1gina generada nav: men\u00fa de navegaci\u00f3n de la p\u00e1gina, compuesto por los distintos archivos de documentaci\u00f3n MarkDown doc_dir: directorio en el que se almacenan los archivos de documentaci\u00f3n theme: en este caso, se ha usado el tema simple-blog","title":"Creaci\u00f3n de MKDocs"},{"location":"gitActions/#descarga-del-tema-local","text":"Como peque\u00f1o inciso, se describir\u00e1n los pasos realizados para la importaci\u00f3n del tema simple-blog . Prerrequisitos: Python instalado, preferiblemente Python 3 (yo he usado la versi\u00f3n 3.12) Los comandos que he empleado son para Windows 10 Instalaci\u00f3n del tema: Para la instalaci\u00f3n del tema, se deber\u00e1 crear un entorno virtual en la carpeta del proyecto: Una vez instalado, lo activamos: Configuraci\u00f3n del tema: Una vez instalado, a\u00f1adimos la l\u00ednea de configuraci\u00f3n pertinente al mkdocs.yml: theme: name: simple-blog","title":"Descarga del tema local"},{"location":"gitActions/#configuracion-del-workflow","text":"Dentro del directorio .github creamos un directorio nuevo llamado \"workflows\" y dentro de este, un archivo de configuraci\u00f3n deploy_docs.yml. En este fichero a\u00f1adiremos las configuraciones de la pipeline: name: el nombre del flujo de trabajo, aparecer\u00e1 en GitHub on: se encarga de definir qu\u00e9 evento lanzar\u00e1 el flujo, en este caso ser\u00e1 on push branches main , ya que se lanzar\u00e1 siempre que se haga un push en la rama main permissions: los permisos del token, para permitir al workflow realizar las operaciones necesarias jobs: define los trabajos que realizar\u00e1 el flujo, en este caso Una vez configurado el archivo, hacemos commit y push para subir los cambios y lanzar la primera ejecuci\u00f3n del flujo de trabajo.","title":"Configuraci\u00f3n del workflow"},{"location":"gitActions/#activacion-de-github-pages","text":"Con la documentaci\u00f3n subida y la rama gh-pages generada por el workflow, ya solo nos queda habilitar la visualizaci\u00f3n de la documentaci\u00f3n mediante la opci\u00f3n de pages de GitHub: Una vez seleccionada esta opci\u00f3n, el despliegue en las p\u00e1ginas se pondr\u00e1 en cola, apareciendo lo siguiente cuando termine: Una vez desplegado, se puede acceder a la documentaci\u00f3n hosteada en este enlace","title":"Activaci\u00f3n de GitHub Pages"}]}